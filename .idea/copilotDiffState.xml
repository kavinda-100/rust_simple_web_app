<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AxumWithRust.http">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AxumWithRust.http" />
              <option name="originalContent" value="### AxumWithRust.http&#10;### This file contains HTTP requests for testing an Axum server built with Rust.&#10;&#10;### Variables&#10;@baseUrl = http://localhost:5000&#10;@contentType = application/json&#10;&#10;&#10;### GET request to root endpoint&#10;GET {{baseUrl}}/&#10;&#10;&#10;### GET request to fetch Vehicle data&#10;GET {{baseUrl}}/vehicle&#10;&#10;### POST request with JSON body&#10;POST {{baseUrl}}/vehicle&#10;Content-Type: {{contentType}}&#10;&#10;{&#10;  &quot;manufacturer&quot;: &quot;Toyota&quot;,&#10;  &quot;name&quot;: &quot;Camry&quot;,&#10;  &quot;model&quot;: &quot;Camry&quot;,&#10;  &quot;year&quot;: 2023,&#10;}&#10;&#10;#### GET request with query parameters&#10;#GET {{baseUrl}}/users?page=1&amp;limit=10&#10;#&#10;#&#10;#### GET request with headers&#10;#GET {{baseUrl}}/protected&#10;#Authorization: Bearer your-token-here&#10;#Accept: application/json&#10;#&#10;#&#10;#### POST request with JSON body&#10;#POST {{baseUrl}}/users&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;John Doe&quot;,&#10;#  &quot;email&quot;: &quot;john@example.com&quot;,&#10;#  &quot;age&quot;: 30&#10;#}&#10;#&#10;#### POST request with form data&#10;#POST {{baseUrl}}/login&#10;#Content-Type: application/x-www-form-urlencoded&#10;#&#10;#username=testuser&amp;password=testpass&#10;#&#10;#&#10;#### PUT request to update resource&#10;#PUT {{baseUrl}}/users/1&#10;#Content-Type: {{contentType}}&#10;#Authorization: Bearer your-token-here&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;John Smith&quot;,&#10;#  &quot;email&quot;: &quot;johnsmith@example.com&quot;,&#10;#  &quot;age&quot;: 31&#10;#}&#10;#&#10;#### PATCH request for partial update&#10;#PATCH {{baseUrl}}/users/1&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;age&quot;: 32&#10;#}&#10;#&#10;#### DELETE request&#10;#DELETE {{baseUrl}}/users/1&#10;#Authorization: Bearer your-token-here&#10;#&#10;#### Environment-specific requests&#10;## @name healthCheck&#10;#GET {{baseUrl}}/health&#10;#&#10;#### Request with response handling (some clients support this)&#10;## @name createUser&#10;#POST {{baseUrl}}/users&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;Jane Doe&quot;,&#10;#  &quot;email&quot;: &quot;jane@example.com&quot;&#10;#}&#10;&#10;### Using response from previous request (if supported by your client)&#10;# GET {{baseUrl}}/users/{{createUser.response.body.id}}&#10;&#10;###" />
              <option name="updatedContent" value="### AxumWithRust.http&#10;### This file contains HTTP requests for testing an Axum server built with Rust.&#10;&#10;### Variables&#10;@baseUrl = http://localhost:5000&#10;@contentType = application/json&#10;&#10;&#10;### GET request to root endpoint&#10;GET {{baseUrl}}/&#10;&#10;&#10;### GET request to fetch Vehicle data&#10;GET {{baseUrl}}/vehicle&#10;&#10;### POST request with JSON body&#10;POST {{baseUrl}}/vehicle&#10;Content-Type: {{contentType}}&#10;&#10;{&#10;  &quot;manufacturer&quot;: &quot;Toyota&quot;,&#10;  &quot;name&quot;: &quot;Camry&quot;,&#10;  &quot;model&quot;: &quot;Camry&quot;,&#10;  &quot;year&quot;: 2023&#10;}&#10;&#10;#### GET request with query parameters&#10;#GET {{baseUrl}}/users?page=1&amp;limit=10&#10;#&#10;#&#10;#### GET request with headers&#10;#GET {{baseUrl}}/protected&#10;#Authorization: Bearer your-token-here&#10;#Accept: application/json&#10;#&#10;#&#10;#### POST request with JSON body&#10;#POST {{baseUrl}}/users&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;John Doe&quot;,&#10;#  &quot;email&quot;: &quot;john@example.com&quot;,&#10;#  &quot;age&quot;: 30&#10;#}&#10;#&#10;#### POST request with form data&#10;#POST {{baseUrl}}/login&#10;#Content-Type: application/x-www-form-urlencoded&#10;#&#10;#username=testuser&amp;password=testpass&#10;#&#10;#&#10;#### PUT request to update resource&#10;#PUT {{baseUrl}}/users/1&#10;#Content-Type: {{contentType}}&#10;#Authorization: Bearer your-token-here&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;John Smith&quot;,&#10;#  &quot;email&quot;: &quot;johnsmith@example.com&quot;,&#10;#  &quot;age&quot;: 31&#10;#}&#10;#&#10;#### PATCH request for partial update&#10;#PATCH {{baseUrl}}/users/1&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;age&quot;: 32&#10;#}&#10;#&#10;#### DELETE request&#10;#DELETE {{baseUrl}}/users/1&#10;#Authorization: Bearer your-token-here&#10;#&#10;#### Environment-specific requests&#10;## @name healthCheck&#10;#GET {{baseUrl}}/health&#10;#&#10;#### Request with response handling (some clients support this)&#10;## @name createUser&#10;#POST {{baseUrl}}/users&#10;#Content-Type: {{contentType}}&#10;#&#10;#{&#10;#  &quot;name&quot;: &quot;Jane Doe&quot;,&#10;#  &quot;email&quot;: &quot;jane@example.com&quot;&#10;#}&#10;&#10;### Using response from previous request (if supported by your client)&#10;# GET {{baseUrl}}/users/{{createUser.response.body.id}}&#10;&#10;###" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.rs" />
              <option name="originalContent" value="use axum::{Router};&#10;use axum::routing::{delete, post, get};&#10;mod vehicle;&#10;use vehicle::*;&#10;&#10;#[tokio::main]&#10;#[allow(dead_code)]&#10;async fn main() {&#10;    // build our application with a single route&#10;    let app = Router::new()&#10;        .route(&quot;/&quot;, get(hello))&#10;        .route(&quot;/vehicle&quot;, get(vehicle_get))&#10;        .route(&quot;/vehicle/query&quot;, get(vehicle_get_by_query))&#10;        .route(&quot;/vehicle&quot;, post(vehicle_post))&#10;        .route(&quot;/vehicle/delete/{id}&quot;, delete(vehicle_delete));&#10;&#10;    // run our app with hyper, listening globally on port 5000&#10;    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:5000&quot;).await.unwrap();&#10;    let app_res= axum::serve(listener, app).await;&#10;    match app_res {&#10;        Ok(_) =&gt; println!(&quot;Server running on http://localhost:5000&quot;),&#10;        Err(e) =&gt; eprintln!(&quot;Server error: {}&quot;, e),&#10;    }&#10;}&#10;&#10;async fn hello() -&gt; &amp;'static str {&#10;    &quot;Hello, World from Axum With Rust! &quot;&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="use axum::{Router};&#10;use axum::routing::{delete, post, get};&#10;mod vehicle;&#10;use vehicle::*;&#10;&#10;#[tokio::main]&#10;#[allow(dead_code)]&#10;async fn main() {&#10;    // build our application with a single route&#10;    let app = Router::new()&#10;        .route(&quot;/&quot;, get(hello))&#10;        .route(&quot;/vehicle&quot;, get(vehicle_get))&#10;        .route(&quot;/vehicle/query&quot;, get(vehicle_get_by_query))&#10;        .route(&quot;/vehicle&quot;, post(vehicle_post))&#10;        .route(&quot;/vehicle/:id&quot;, delete(vehicle_delete));&#10;&#10;    // run our app with hyper, listening globally on port 5000&#10;    let listener = tokio::net::TcpListener::bind(&quot;0.0.0.0:5000&quot;).await.unwrap();&#10;    let app_res= axum::serve(listener, app).await;&#10;    match app_res {&#10;        Ok(_) =&gt; println!(&quot;Server running on http://localhost:5000&quot;),&#10;        Err(e) =&gt; eprintln!(&quot;Server error: {}&quot;, e),&#10;    }&#10;}&#10;&#10;async fn hello() -&gt; &amp;'static str {&#10;    &quot;Hello, World from Axum With Rust! &quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/vehicle.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/vehicle.rs" />
              <option name="originalContent" value="use axum::extract::Query;&#10;use axum::http::StatusCode;&#10;use axum::response::IntoResponse;&#10;use axum::Json;&#10;use serde::{Deserialize, Serialize};&#10;&#10;#[derive(Debug)]&#10;#[derive(Serialize, Deserialize)]&#10;pub struct Vehicle {&#10;    id: Option&lt;String&gt;,&#10;    manufacturer: String,&#10;    name: String,&#10;    model: String,&#10;    year: u32,&#10;}&#10;// get the vehicle details&#10;pub async fn vehicle_get() -&gt; impl IntoResponse {&#10;    let vehicle = Vehicle {&#10;        id: Some(uuid::Uuid::new_v4().to_string()),&#10;        manufacturer: &quot;BMW&quot;.to_string(),&#10;        name: &quot;BMW&quot;.to_string(),&#10;        model: &quot;CS&quot;.to_string(),&#10;        year: 2024,&#10;    };&#10;    (StatusCode::OK, Json(vehicle))&#10;}&#10;&#10;// get vehicle details by query parameter&#10;pub async fn vehicle_get_by_query(Query(mut v): Query&lt;Vehicle&gt;) -&gt; impl IntoResponse {&#10;    // If the ID is not set, assign a new UUID&#10;    if v.id.is_none() {&#10;        v.id = Some(uuid::Uuid::new_v4().to_string());&#10;    }&#10;    // Log the received vehicle query&#10;    println!(&quot;Received vehicle query: {:?}&quot;, v);&#10;    &#10;    // Here you would typically fetch the vehicle from a database or perform some action&#10;    // For now, we just return the vehicle as is&#10;    (StatusCode::OK, Json(v))&#10;}&#10;&#10;// post a new vehicle&#10;pub async fn vehicle_post(Json(mut v): Json&lt;Vehicle&gt;) -&gt; impl IntoResponse {&#10;    // Assign a new UUID to the vehicle if it doesn't have one&#10;    v.id = Some(uuid::Uuid::new_v4().to_string());&#10;    // Log the received vehicle&#10;    println!(&quot;Received vehicle: {:?}&quot;, v);&#10;    // Here you would typically save the vehicle to a database or perform some action&#10;    // For now, we just print it to the console&#10;    (StatusCode::CREATED, Json(v)) // Return 201 Created with the vehicle data&#10;}&#10;&#10;// delete a vehicle&#10;pub async fn vehicle_delete() -&gt; impl IntoResponse {&#10;    // This function would handle deletion logic, but for now, we return a placeholder response&#10;    (StatusCode::NO_CONTENT, &quot;Vehicle deleted successfully&quot;)&#10;}" />
              <option name="updatedContent" value="use axum::extract::{Query, Path};&#10;use axum::http::StatusCode;&#10;use axum::response::IntoResponse;&#10;use axum::Json;&#10;use serde::{Deserialize, Serialize};&#10;&#10;#[derive(Debug)]&#10;#[derive(Serialize, Deserialize)]&#10;pub struct Vehicle {&#10;    id: Option&lt;String&gt;,&#10;    manufacturer: String,&#10;    name: String,&#10;    model: String,&#10;    year: u32,&#10;}&#10;// get the vehicle details&#10;pub async fn vehicle_get() -&gt; impl IntoResponse {&#10;    let vehicle = Vehicle {&#10;        id: Some(uuid::Uuid::new_v4().to_string()),&#10;        manufacturer: &quot;BMW&quot;.to_string(),&#10;        name: &quot;BMW&quot;.to_string(),&#10;        model: &quot;CS&quot;.to_string(),&#10;        year: 2024,&#10;    };&#10;    (StatusCode::OK, Json(vehicle))&#10;}&#10;&#10;// get vehicle details by query parameter&#10;pub async fn vehicle_get_by_query(Query(mut v): Query&lt;Vehicle&gt;) -&gt; impl IntoResponse {&#10;    // If the ID is not set, assign a new UUID&#10;    if v.id.is_none() {&#10;        v.id = Some(uuid::Uuid::new_v4().to_string());&#10;    }&#10;    // Log the received vehicle query&#10;    println!(&quot;Received vehicle query: {:?}&quot;, v);&#10;    &#10;    // Here you would typically fetch the vehicle from a database or perform some action&#10;    // For now, we just return the vehicle as is&#10;    (StatusCode::OK, Json(v))&#10;}&#10;&#10;// post a new vehicle&#10;pub async fn vehicle_post(Json(mut v): Json&lt;Vehicle&gt;) -&gt; impl IntoResponse {&#10;    // Assign a new UUID to the vehicle if it doesn't have one&#10;    v.id = Some(uuid::Uuid::new_v4().to_string());&#10;    // Log the received vehicle&#10;    println!(&quot;Received vehicle: {:?}&quot;, v);&#10;    // Here you would typically save the vehicle to a database or perform some action&#10;    // For now, we just print it to the console&#10;    (StatusCode::CREATED, Json(v)) // Return 201 Created with the vehicle data&#10;}&#10;&#10;// delete a vehicle&#10;pub async fn vehicle_delete(Path(id): Path&lt;String&gt;) -&gt; impl IntoResponse {&#10;    // Log the received vehicle ID for deletion&#10;    println!(&quot;Deleting vehicle with ID: {}&quot;, id);&#10;    &#10;    // Here you would typically delete the vehicle from a database&#10;    // For now, we just return a success response&#10;    (StatusCode::NO_CONTENT, format!(&quot;Vehicle with ID {} deleted successfully&quot;, id))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>